Long Parsed Items
b  - block, { ... }
"  - quote
l  - list, comma seperated items, keywords processed
L  - parameter list, same as list, but surrounded by parentheses
s  - Signature
S  - Signature in parentheses
q  - quoted text, quote delimiters allowed listed in brackets, quote used is passed to keyword
c  - code
C  - code in parentheses
.  - Slurp, (anything goes)
D  - Delimiter specified at use, (must occur twice at minimum, special handling for open/close things)

Simple Items
w  - word, alphanumeric starting with alpha
n  - number, alphanumeric starting with number
_  - whitespace

Positioning
^  - start of line
$  - end of line
<  - grab items before keyword in this statement
>  - look ahead at next token
/  - NoWhitespace

Extra Behavior
t       - terminate statement here
{...}   - Data, Symbols to make available (used in blocks, code, parameter list, etc)

Modifiers
?     - Optional
*     - Any number
+     - One or more

Constructs
(|) - this or that

--------------------------

"           '"'
'           '"'
`           '"'

++          '(C|/w|<|w)'    If not followed by a space grab the next token,
--          '(C|/w|<|w)'    otherwise bind left, if nothing left bind right

::          '<

{           "c -}-"
[           "l -]-"
(           "c -)-"
[[          "l -]]-"

func        'w S? b t'
meth        'w S? b t'
sub         'b'
type        'w C? b{meth,with,has} t'

fennec      '(l|q) L? b t'

#######
    var thing x(...)
    var thing x(...), y(...)
    var thing x 1, y 1
    var thing x "...", y "..."

    var thing x, y;
    var thing x, y = ...;

    var thing x;
    var thing x = ...;

    var x, y;
    var x, y = ...

    var x;
    var x = ...;

var         '( (w (w (n|q|L)-,-)* (n|q|L)-,-?) -;- | ((w l)|(w w)|l|w) (-;-|-=-) )'
#######

sigil       '/w'

qq          'D . D . D'
s           'D . D . D

->          'w <'
+>          'w'
~>          'w < w'

]=[         'c -]-'

//          '. $'

unless      '(< c|(c b|C b) t)'
if          '(< c|((c b|C b) (-elsif- (c b|C b))* (-else- b)? t))'

while       '(< c|(c b|C b) t)'
until       '(< c|(c b|C b) t)'

for         '(  < w (L|(w,)* w,?)    |   w (L|(w,)* w,?) b  )'

load        '(w (-::- w)*|q)'

try         'b (-catch- C b)? (-finally- b)? t'

keyword     'w q b'


-----------------------------------

{
    look: '<' or '>'
    want: 'char'
    modi: 'char'
    syms: [...]
    altr: ...
    next: ...

    look_idx: # token number from keyword, 1 is just before keyword, 2 is 2
                before keyword, etc. If 0 then grab entire statement before
                Not used for >
}
